/*
   Copyright (C) 1999-2006 Id Software, Inc. and contributors.
   For a list of contributors, see the accompanying CONTRIBUTORS file.

   This file is part of GtkRadiant.

   GtkRadiant is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   GtkRadiant is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GtkRadiant; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/*
   Light Probe Visualization
   
   Renders light probe positions from .probes files generated by remap compiler.
   Probes are displayed as colored points/spheres in the 3D and 2D views to help
   debug probe placement issues.
*/

#include "probes.h"

#include "debugging/debugging.h"

#include "irender.h"
#include "igl.h"
#include "renderable.h"

#include "stream/stringstream.h"
#include "os/path.h"
#include "os/file.h"
#include "commandlib.h"

#include "map.h"
#include "qe3.h"
#include "camwindow.h"
#include "xywindow.h"
#include "mainframe.h"
#include "commands.h"

// Maximum number of probes to visualize
#define MAX_PROBES 16384

// Probe data structure
struct LightProbeVis {
    Vector3 position;
    Vector3 color;  // RGB ambient color from probe
};

class CProbeFile : public Renderable, public OpenGLRenderable
{
    LightProbeVis m_probes[MAX_PROBES];
    std::size_t m_num_probes;
    int m_displaylist;
    static Shader* m_renderstate;
    
public:
    CProbeFile() : m_num_probes(0), m_displaylist(0) {
    }
    
    ~CProbeFile() {
    }
    
    void Init() {
        m_num_probes = 0;
        m_displaylist = 0;
    }
    
    void PushProbe(const Vector3& pos, const Vector3& color) {
        if (m_num_probes < MAX_PROBES) {
            m_probes[m_num_probes].position = pos;
            m_probes[m_num_probes].color = color;
            ++m_num_probes;
        }
    }
    
    void GenerateDisplayList() {
        if (m_num_probes == 0) return;
        
        m_displaylist = gl().glGenLists(1);
        gl().glNewList(m_displaylist, GL_COMPILE);
        
        // Draw probes as colored points with size
        gl().glPointSize(8.0f);
        gl().glBegin(GL_POINTS);
        for (std::size_t i = 0; i < m_num_probes; i++) {
            // Use probe's ambient color, brightened for visibility
            float r = std::min(1.0f, m_probes[i].color[0] * 2.0f + 0.2f);
            float g = std::min(1.0f, m_probes[i].color[1] * 2.0f + 0.2f);
            float b = std::min(1.0f, m_probes[i].color[2] * 2.0f + 0.2f);
            gl().glColor3f(r, g, b);
            gl().glVertex3fv(vector3_to_array(m_probes[i].position));
        }
        gl().glEnd();
        
        // Also draw small crosses at each probe for better visibility
        gl().glLineWidth(2.0f);
        gl().glBegin(GL_LINES);
        const float crossSize = 24.0f;
        for (std::size_t i = 0; i < m_num_probes; i++) {
            float r = std::min(1.0f, m_probes[i].color[0] * 2.0f + 0.2f);
            float g = std::min(1.0f, m_probes[i].color[1] * 2.0f + 0.2f);
            float b = std::min(1.0f, m_probes[i].color[2] * 2.0f + 0.2f);
            gl().glColor3f(r, g, b);
            
            const Vector3& p = m_probes[i].position;
            // X axis
            gl().glVertex3f(p[0] - crossSize, p[1], p[2]);
            gl().glVertex3f(p[0] + crossSize, p[1], p[2]);
            // Y axis
            gl().glVertex3f(p[0], p[1] - crossSize, p[2]);
            gl().glVertex3f(p[0], p[1] + crossSize, p[2]);
            // Z axis
            gl().glVertex3f(p[0], p[1], p[2] - crossSize);
            gl().glVertex3f(p[0], p[1], p[2] + crossSize);
        }
        gl().glEnd();
        gl().glLineWidth(1.0f);
        gl().glPointSize(1.0f);
        
        gl().glEndList();
    }
    
    bool shown() const {
        return m_displaylist != 0;
    }
    
    std::size_t count() const {
        return m_num_probes;
    }
    
    void show(bool show);
    
    void render(RenderStateFlags state) const {
        if (m_displaylist != 0) {
            gl().glCallList(m_displaylist);
        }
    }
    
    void renderSolid(Renderer& renderer, const VolumeTest& volume) const {
        if (shown()) {
            renderer.SetState(m_renderstate, Renderer::eWireframeOnly);
            renderer.SetState(m_renderstate, Renderer::eFullMaterials);
            renderer.addRenderable(*this, g_matrix4_identity);
        }
    }
    
    void renderWireframe(Renderer& renderer, const VolumeTest& volume) const {
        renderSolid(renderer, volume);
    }
    
    static void constructStatic() {
        // Reuse the pointfile shader - it's already registered and works for our needs
        m_renderstate = GlobalShaderCache().capture("$POINTFILE");
    }
    
    static void destroyStatic() {
        GlobalShaderCache().release("$POINTFILE");
    }
};

Shader* CProbeFile::m_renderstate = 0;

namespace {
    CProbeFile s_probefile;
}


static bool LoadProbeFile(CProbeFile& probefile) {
    const char* mapname = Map_Name(g_map);
    StringOutputStream filename(256);
    
    // Try to load .probes file
    filename(PathExtensionless(mapname), ".probes");
    
    FILE* f = fopen(filename.c_str(), "r");
    if (!f) {
        globalErrorStream() << "Probe file " << filename << " not found\n";
        return false;
    }
    
    globalOutputStream() << "Loading probe file " << filename << '\n';
    
    probefile.Init();
    
    char line[256];
    int lineNum = 0;
    int probeCount = 0;
    
    while (fgets(line, sizeof(line), f)) {
        lineNum++;
        
        // Skip comments and empty lines
        if (line[0] == '#' || line[0] == '\n' || line[0] == '\r') {
            continue;
        }
        
        float x, y, z, r = 0.5f, g = 0.5f, b = 0.5f;
        
        // Try to parse with color first
        int parsed = sscanf(line, "%f %f %f %f %f %f", &x, &y, &z, &r, &g, &b);
        if (parsed < 3) {
            globalWarningStream() << "Corrupt probe file, line " << lineNum << '\n';
            continue;
        }
        
        probefile.PushProbe(Vector3(x, y, z), Vector3(r, g, b));
        probeCount++;
    }
    
    fclose(f);
    
    if (probeCount > 0) {
        probefile.GenerateDisplayList();
        globalOutputStream() << "Loaded " << probeCount << " light probes\n";
        return true;
    }
    
    return false;
}


void CProbeFile::show(bool show) {
    if (show && !shown()) {
        LoadProbeFile(*this);
        if (m_num_probes > 0) {
            GenerateDisplayList();
            SceneChangeNotify();
        }
    }
    else if (!show && shown()) {
        gl().glDeleteLists(m_displaylist, 1);
        m_displaylist = 0;
        SceneChangeNotify();
    }
}


void Probes_Clear() {
    s_probefile.show(false);
}

void Probes_Toggle() {
    if (s_probefile.shown()) {
        s_probefile.show(false);
        globalOutputStream() << "Light probes hidden\n";
    } else {
        s_probefile.show(true);
        if (s_probefile.shown()) {
            globalOutputStream() << "Showing " << s_probefile.count() << " light probes\n";
        }
    }
}

bool Probes_Shown() {
    return s_probefile.shown();
}

void Probes_Construct() {
    CProbeFile::constructStatic();
    GlobalShaderCache().attachRenderable(s_probefile);
    GlobalCommands_insert("ToggleLightProbes", FreeCaller<Probes_Toggle>(), QKeySequence("Ctrl+Shift+P"));
}

void Probes_Destroy() {
    GlobalShaderCache().detachRenderable(s_probefile);
    CProbeFile::destroyStatic();
}

